<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.03">
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

 
<title> DRAFT\ JavaCC FAQ</title>
 
<h1 align="center">DRAFT&nbsp;JavaCC FAQ </h1>

<h3 align="center">Maintained by Theodore S. Norvell<br />Computer and Electrical Engineering<br />Memorial University of Newfoundland<br />Email: theo at engr.mun.ca </h3>

<h3 align="center">Typeset on Dec  7, 2001
. </h3>


<h1>Contents </h1><a href="#tth_chAp1"
>1&nbsp; General Information on JavaCC and Parsing</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1"
>1.1&nbsp; What is JavaCC?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.2"
>1.2&nbsp; Could you explain that in more detail?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.3"
>1.3&nbsp; What does JavaCC not do?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.4"
>1.4&nbsp; What can JavaCC be used for?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.5"
>1.5&nbsp; What is comp.compilers.tools.javacc?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.6"
>1.6&nbsp; Is there a mailing list?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.7"
>1.7&nbsp; Who wrote JavaCC and who maintains it?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.8"
>1.8&nbsp; Where can I get JavaCC?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.9"
>1.9&nbsp; What legal restrictions are there on JavaCC.</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.10"
>1.10&nbsp; Are there books or tutorials on JavaCC</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.11"
>1.11&nbsp; Are there books or tutorials on parsing theory?</a><br />
<a href="#tth_chAp2"
>2&nbsp; The Big Picture</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Is there any documentation?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; What files does JavaCC produce?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; I changed option <i>x</i>; why am I having trouble?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4"
>2.4&nbsp; How do I&nbsp;put the generated classes in a package?</a><br />
<a href="#tth_chAp3"
>3&nbsp; The Token Manager</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; What is a token manager?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; How do I read from a string instead of a file?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; What if more than one regular expression matches a prefix of the remaining input?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4"
>3.4&nbsp; What if no regular expression matches a prefix of the remaining input?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5"
>3.5&nbsp; How do I match any character?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.6"
>3.6&nbsp; How do I match exactly <i>n</i> repetitions of a regular expression?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.7"
>3.7&nbsp; What are lexical states all about?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.8"
>3.8&nbsp; Why do the example Java and C++ parsers report an error when the last line of a file is a single line comment?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.9"
>3.9&nbsp; What is a common token action?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.10"
>3.10&nbsp; How do I throw a ParseException instead of a TokenMgrError?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.11"
>3.11&nbsp; Why are line and column numbers not recorded?</a><br />
<a href="#tth_chAp4"
>4&nbsp; The Parser and Lookahead</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; Where should I draw the line between lexical analysis and parsing?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; What is recursive descent parsing?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3"
>4.3&nbsp; What is left-recursion and why can't I use it?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4"
>4.4&nbsp; I get a message saying ``Warning: Choice Conflict ... ''; what should I do?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5"
>4.5&nbsp; I&nbsp;added a LOOKAHEAD specification and the warning went away; does that mean I&nbsp;fixed the problem?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6"
>4.6&nbsp; Are semantic actions executed during syntactic lookahead?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7"
>4.7&nbsp; Is semantic lookahead evaluated during syntactic lookahead?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.8"
>4.8&nbsp; How does JavaCC differ from standard LL(1) parsing?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.9"
>4.9&nbsp; How do I communicate from the parser to the token manager?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.10"
>4.10&nbsp; How do I communicate from the token manager to the parser?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.11"
>4.11&nbsp; What does it mean to put a regular expression within a BNF&nbsp;production?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.12"
>4.12&nbsp; When should regular expressions be put directly into a BNF&nbsp;production?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.13"
>4.13&nbsp; How do I parse a sequence without allowing duplications?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.14"
>4.14&nbsp; There's an error in the input, so why doesn't my parser throw a ParseException?</a><br />
<a href="#tth_chAp5"
>5&nbsp; Semantic Actions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; I've written/found a parser, but it doesn't do anything?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; How do I capture and traverse a sequence of tokens?</a><br />
<a href="#tth_chAp6"
>6&nbsp; JJTree and JTB</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; What are JJTree and JTB</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; Where can I&nbsp;find JJTree</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; Where can I find JTB</a><br />
<a href="#tth_chAp7"
>7&nbsp; Applications of JavaCC</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1"
>7.1&nbsp; Where can I find a parser for <i>x</i>.</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2"
>7.2&nbsp; How do I parse arithmetic expressions?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3"
>7.3&nbsp; I'm writing a programming language interpreter; how do I deal with loops?</a><br />
 

<p>

<p>
<b>TO DO</b>

<p>

<ul><p>
<li>  Add acknowledgments</li>
<p>
<li>  Remove word
"DRAFT'' from title.</li>
<p>
<li>  Finish to do list.
<p>
<br /><br /></li>
</ul>

<p>
The latest copy of this FAQ can be found at
<A href="http://www.engr.mun.ca/~theo/JavaCC-FAQ/">The JavaCC FAQ</A>.
<p>
In citing or linking to this FAQ, please use the following URI:
<p>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<i>http</i>://<i>www</i>.<i>engr</i>.<i>mun</i>.<i>ca</i>/~<i>theo</i>/<i>JavaCC</i><font face="symbol">-</font
><i>FAQ</i></td></tr></table>
</td></tr></table>



<p>
 <h1><a name="tth_chAp1">
Chapter 1 </a><br />General Information on JavaCC and Parsing</h1>

<p>

<center><em>"DRAGONS&nbsp;DREAD</em>

<p>
<em>GO&nbsp;BACK TO&nbsp;BED!!''</em>

<p>
Sheree Fitch, <em>Sleeping Dragons All Around.
<p>
<br /><br /></em></center> <h2><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;What is JavaCC?</h2>

<p>
JavaCC stands for
"the Java Compiler Compiler''; it is a parser generator and lexical analyzer
generator. JavaCC will read a description of a language and generate code,
written in Java, that will read and analyze that language. JavaCC is
particularly useful when the input language has a complex structure that makes
hand-crafting an input module a difficult job.

<p>
This technology originated to make programming language implementation easier
- hence the term
"compiler compiler'' - but make no mistake that JavaCC is of use only to
programming language implementors.

<p>
 <h2><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Could you explain that in more detail?</h2>

<p>
Figure <a href="#big-pic">1.1</a> shows the relationship between a JavaCC generated lexical
analyzer (called a
"token manager'' in JavaCC parlance) and a JavaCC generated parser. The picture
shows the C&nbsp;as the input language. But JavaCC can handle any language -and
not only programming languages- if you can describe the rules of the
language to JavaCC.

<p>
The token manager reads in a sequence of characters and produces a sequence of
objects called
"tokens''. The rules used to break the sequence of characters into a sequence
of tokens obviously depend on the language; they are supplied by the
programmer as a collection of
"regular expressions''.

<p>
The parser consumes the sequence of tokens, analyses its structure, and
produces ... . Well what the parser produces is up to you; JavaCC is
completely flexible in this regard<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>. The figure shows an
"abstract syntax tree'', but you might want to produce, say, a number (if you
are writing a calculator), a file of assembly language (if you were writing a
one-pass compiler), a modified sequence of characters (if you were writing a
text processing application), and so on. The programmer supplies a collection
of
"Extended BNF&nbsp;production rules''; JavaCC uses these productions to generate
the parser as a Java&nbsp;class. These production rules can be annotated with
snippets of Java code, which is how the programmer tells the parser what to produce.
<p>

<p>
<a name="tth_fIg1.1">
</a> [th]

<center>
<a href="big-picture.gif">Figure</a>
<center>Figure 1.1: The relationship between the token manager and the parser.</center><A NAME="big-pic"></A></center>

<p>

<p>
 <h2><a name="tth_sEc1.3">
1.3</a>&nbsp;&nbsp;What does JavaCC not do?</h2>

<p>
JavaCC does not build trees (or generate tree building classes), although
there are at least two tree building tools
JJTree and JTB (see Chapter <a href="#jjtree-and-jtb">6</a>.)based on JavaCC, and building parse trees
"by hand'' with a JavaCC based parser is easy.

<p>
JavaCC&nbsp;does not build symbol-tables, although if you want a symbol table for
a language, then a JavaCC based parser may provide a good framework.

<p>
JavaCC does not generate output languages. However once you have a tree, it is
easy to generate output from it.

<p>
 <h2><a name="tth_sEc1.4">
1.4</a>&nbsp;&nbsp;What can JavaCC be used for?</h2>

<p>
JavaCC has been used to create parsers for: RTF, Visual Basic, Python,
Rational Rose mdl files, XML, XML DTDs, HTML, C, C++, Java, JavaScript,
Oberon, SQL, VHDL, VRML, ASN1, email headers, and lots of proprietary
languages. It also get used for configuration files, calculators, and on and on.

<p>
 <h2><a name="tth_sEc1.5">
1.5</a>&nbsp;&nbsp;What is comp.compilers.tools.javacc?</h2>

<p>
comp.compilers.tools.javacc is a usenet newsgroup for discussing the JavaCC
and related technologies, like JJTree and JTB.

<p>
It is not a suitable forum for discussing the Java programming language or
javac, which is Sun's Java compiler, or any other topic that does not relate
directly to the Java Compiler Compiler.

<p>
If you have a question about Java or javac, don't sent it to comp.compilers.tools.javacc.

<p>
Questions on parsing theory in general might be better addressed to comp.compilers.

<p>
 <h2><a name="tth_sEc1.6">
1.6</a>&nbsp;&nbsp;Is there a mailing list?</h2>

<p>
Yes. To subscribe send a message to javacc-interest-request@webgain.com.

<p>
Eventually the mailing list and comp.compilers.tools.javacc will be gatewayed.

<p>
 <h2><a name="tth_sEc1.7">
1.7</a>&nbsp;&nbsp;Who wrote JavaCC and who maintains it?</h2>

<p>
JavaCC was created by Sreeni Viswanadha and Sriram Sankar when they worked for
Sun. They then formed their own company, Metamata, which is now a wholly owned
subsidiary of WebGain. Through all these changes, they've kept improving
JavaCC. Because of this history, JavaCC is owned by Sun Microsystems.

<p>
 <h2><a name="tth_sEc1.8">
1.8</a>&nbsp;&nbsp;Where can I get JavaCC?<A NAME="where-is-javacc"></A></h2>

<p>
JavaCC is available from
<A href="http://www.webgain.com/products/java_cc/">WebGain</A>&nbsp;as a free download. The precise URL may change.

<p>
 <h2><a name="tth_sEc1.9">
1.9</a>&nbsp;&nbsp;What legal restrictions are there on JavaCC.</h2>

<p>
There are essentially no restrictions on the use of JavaCC. In particular you
may use the Java files that JavaCC produces in any way, including
incorporating them into a product that you sell. However, you are not allowed
to redistribute JavaCC itself; it is free, but it is not shareware.
Furthermore various .jj files that are distributed with JavaCC or that you may
find on the net, may have restrictions on their use - read the copyright
notices carefully.

<p>
 <h2><a name="tth_sEc1.10">
1.10</a>&nbsp;&nbsp;Are there books or tutorials on JavaCC</h2>

<p>
At the moment there are no books on JavaCC

<p>
There are some tutorial examples in the JavaCC&nbsp;documentation.

<p>
Your maintainer is considering creating a tutorial web-site, but would be
relieved to find out that there are tutorial web-sites that he is not aware of.

<p>
 <h2><a name="tth_sEc1.11">
1.11</a>&nbsp;&nbsp;Are there books or tutorials on parsing theory?</h2>

<p>
Yes many. Most text-books on compiler technology contain more than enough
background on parsing theory. Here are some suggestions

<p>

<ul><p>
<li>  Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman, <em>Compilers:
Principles, Techniques, and Tools</em>, Addison-Wesley, 1985.</li>
<p>
<li>  Charles N. Fischer and Richard J. Leblanc, Jr., <em>Crafting a
Compiler With C</em>, Addison-Wesley, 1991.</li>
</ul>

<p>
 <h1><a name="tth_chAp2">
Chapter 2 </a><br />The Big Picture</h1>

<p>
 <h2><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Is there any documentation?<A NAME="javacc-doc"></A></h2>

<p>
Yes.
<A href="http://www.webgain.com/products/java_cc/documentation.html">Follow this link</A>.

<p>
The on-line documentation is currently a bit out of date. You should also read
the release notes that come with the JavaCC download.

<p>
The documentation is rather terse and is much easier to read if you already
know a bit about parsing theory. Nevertheless, the documentation is an
indispensable resources that is in no way superceded by this FAQ.

<p>
It used to be possible to download the documentation in a big ZIP file. At the
moment your maintainer does not know where the documentation can be downloaded
from, but you can certainly view it on-line.

<p>
 <h2><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;What files does JavaCC produce?<A NAME="what-files"></A></h2>

<p>
JavaCC is a program generator. Based on its input (a .jj file) it will produce
the following Java source files:

<p>

<ul><p>
<li>  Boiler-plate files

<p>

<ul><p>
<li>  Either SimpleCharStream.java or JavaCharStream.java - represent the
stream of input characters&nbsp;(prior to version 2.1, one of four possible files
was generated: ASCII_CharStream.java ASCII_UCodeESC_CharStream.java
UCode_CharStream.java or UCode_UCodeESC_CharStream.java).</li>
<p>
<li>  Token.java - represents a single input token</li>
<p>
<li>  TokenMgrError.java - an error thrown from the token manager.</li>
<p>
<li>  ParseException.java - an exception indicating that the input did not
conform to the parser's grammar.</li>
</ul></li>
<p>
<li>  Custom files (<em>XXX</em> is whatever name you choose).

<p>

<ul><p>
<li> <em>XXX</em>.java - the parser class</li>
<p>
<li> <em>XXX</em>TokenManager.java - the token manager class.</li>
<p>
<li> <em>XXX</em>Constants.java - an interface associating token classes with
symbolic names.</li>
</ul></li>
</ul>

<p>
The boiler plate files will only be produced if they don't already exist; this
means you should delete them prior to running JavaCC, if you make any changes
that might require changes to these files. (See
Question <a href="#option-changed">2.3</a>, ``I changed option <i>x</i>; why am I having
trouble?''.)

<p>
The custom files are produced every time you run JavaCC.

<p>
 <h2><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;I changed option <i>x</i>; why am I having trouble?<A NAME="option-changed"></A></h2>

<p>
Try deleting <b>all</b> files generated by JavaCC (see
Question <a href="#what-files">2.2</a>, "What files does JavaCC produce?'') and then rerunning JavaCC. This issue usually comes up when the
<font face="helvetica">STATIC</font> option is changed; JavaCC needs to generate new files, but it
will not generate boiler-plate files unless they aren't there already.

<p>
 <h2><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;How do I&nbsp;put the generated classes in a package?</h2>

<p>
Put a <font face="helvetica">package</font> declaration right after the <font face="helvetica">PARSER_BEGIN(</font><em>XXX</em><font face="helvetica">)</font> declaration in the .jj file.

<p>
 <h1><a name="tth_chAp3">
Chapter 3 </a><br />The Token Manager</h1>

<p>
 <h2><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;What is a token manager?</h2>

<p>
In conventional compiling terms, a token manager is a lexical analyzer. If
that is Greek to you, here is an explanation. The token manager analyzes the
input stream of characters breaking it up into chunks called tokens and
assigning each token a
"token kind''. For example suppose the input is a C&nbsp;file

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<tt>int main() {</tt>

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><tt>/*a short program */</tt></dd>
 <dt><b></b></dt>
	<dd><tt>return 0 ; }</tt></dd>
</dl>
</TD></TR></TABLE></font>

<p>
Then the token manager might break this into chunks as follows:

<p>

<center>"<tt>int</tt>''
"&nbsp;''
"<tt>main</tt>''
"<tt>(</tt>''
"<tt>)</tt>''
"&nbsp;''
"<tt>{</tt>''
"\n''
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;''
"<tt>/*a short program */</tt>'' ...
</center>

<p>
White space and comments are typically discarded, so the chunks are then

<p>

<center>"<tt>int</tt>''
"<tt>main</tt>''
"<tt>(</tt>''
"<tt>)</tt>''
"<tt>{</tt>''
"<tt>return</tt>''
"<tt>0</tt>''
"<tt>;</tt>''
"<tt>}</tt>''
</center>

<p>
Each chunk of text is classified as one of a finite set of
"token kinds''.<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a> For example

<p>

<center><font face="helvetica">KWINT ID LPAR RPAR LBRACE KWRETURN OCTALCONST SEMICOLON&nbsp;RBRACE</font>
</center>

<p>
Each chunk of text is represented by an object of class Token, each with the
following attributes:

<p>

<ul><p>
<li> <font face="helvetica">.kind</font> the token kind encoded as an int,</li>
<p>
<li> <font face="helvetica">.image</font> the chunk of input text as a string,</li>
</ul>

<p>
 and a few others.

<p>
This sequence of Token objects is produced based on regular expressions
appearing in the .jj file.

<p>
The sequence is usually sent on to a parser object for further processing.

<p>
 <h2><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;How do I read from a string instead of a file?</h2>

<p>
Here is one way

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
java.io.StringReader sr = <b>new</b> java.io.StringReader( str );

<p>
java.io.Reader r = <b>new</b> java.io.BufferedReader( sr );

<p>
XXX parser = <b>new</b> XXX( r );
</TD></TR></TABLE></font>

<p>
 <h2><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;What if more than one regular expression matches a prefix of the
remaining input?<A NAME="more-than-one"></A></h2>

<p>
There are three golden rules for picking which regular expression to use to
identify the next token:

<p>

<ol type="1"><p>
<li>  The regular expression must describe a prefix of the remaining input stream.</li>
<p>
<li>  If more than one regular expression describes a prefix, then the
regular expression that describes the longest possible prefix of the input
stream is used. (This is called the
"maximal munch rule''.)</li>
<p>
<li>  If more than one regular expression describes the longest possible
prefix, then the regular expression that comes first in the .jj file is used.</li>
</ol>

<p>
For example, suppose you are parsing Java, C, or C++. The following three
regular expression productions might appear in the .jj file

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>TOKEN</b> :&nbsp;{&nbsp; &lt; PLUS :
"+''
 &gt; }

<p>
<b>TOKEN</b> :&nbsp;{&nbsp; &lt; ASSIGN :
"=''
 &gt; }

<p>
<b>TOKEN</b>&nbsp;:&nbsp;{
 &lt; PLASSIGN :
"+=''&nbsp; &gt; }
</TD></TR></TABLE></font>

<p>
 Suppose the remaining input stream starts with

<p>

<center>"<tt>+=1; </tt>...''&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.
</center>

<p>
 Rule 1 rules out the second production. Rule 2 says that the third
production is preferred over the first. The order of the productions has no
effect on this example

<p>
Sticking with Java, C, or C++, suppose you have regular expression productions

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>TOKEN</b> :&nbsp;{&nbsp; &lt; KWINT :&nbsp;"int''
 &gt; }

<p>
<b>TOKEN</b> :&nbsp;{&nbsp; &lt; IDENT : ["a''-"z'',"A''-"Z'',
"_''] (["a''-"z'',"A''-"Z'',"0''-"9'',"_''])*
 &gt; }
</TD></TR></TABLE></font>

<p>
 Suppose the remaining input steams starts with

<p>

<center>"<tt>integer i; </tt>...''&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,
</center>

<p>
 then the second production would be preferred by the maximal munch
rule (rule 2). But if the remaining input stream starts with

<p>

<center>"<tt>int i; </tt>...''&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,
</center>

<p>
 then the maximal munch rule is no help, since both rules match a
prefix of length 3. In this case the <font face="helvetica">KWINT</font> production is preferred
(by rule 3) because it comes first in the .jj file.

<p>
 <h2><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;What if no regular expression matches a prefix of the remaining input?</h2>

<p>
Then a TokenMgrError is thrown.

<p>
 <h2><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;How do I match any character?</h2>

<p>
Use ~[] .

<p>
 <h2><a name="tth_sEc3.6">
3.6</a>&nbsp;&nbsp;How do I match exactly <i>n</i> repetitions of a regular expression?</h2>

<p>
If <i>X</i> is the regular expression, write
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
(<i>X</i>){<i>n</i>}</td></tr></table>
</td></tr></table>


You can also give a lower and upper bound on the number of repetitions:
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
(<i>X</i>){<i>l</i>,<i>u</i>}</td></tr></table>
</td></tr></table>



<p>
 <h2><a name="tth_sEc3.7">
3.7</a>&nbsp;&nbsp;What are lexical states all about?</h2>

<p>
Lexical states allow you to bring different sets of regular expression
productions in-to and out-of effect.

<p>
Suppose you wanted to write a JavaDoc processor. Most of Java is tokenized
according to regular ordinary Java rules. But between a
"<tt>/**</tt>'' and the next
"<tt>*/</tt>'' a different set of rules applies in which keywords like
"<tt>@param</tt>'' must be recognized and where newlines are significant. To
solve this problem, we could use two lexical states. One for regular Java
tokenizing and one for tokenizing within JavaDoc comments.

<p>
Lexical states are also useful for breaking down complex regular expressions.
Suppose you want to skip C style comments. You could write a regular
expression production:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>SKIP</b>&nbsp;:&nbsp;{&nbsp;"/*'' (~["*'']
<font face="symbol">|</font
>&nbsp;("*'')+ ~["/''])* ("*'')+
"/'' }
</TD></TR></TABLE></font>

<p>
 But how confident are you that this is right?&nbsp;The following version
uses a lexical state called <font face="helvetica">IN_COMMENT</font> to make things much clearer:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<em>// When a /* is seen in the DEFAULT&nbsp;state, switch to the IN_COMMENT&nbsp;state</em>

<p>
<b>SKIP</b>&nbsp;{

<p>

<dl compact="compact">

	<dd>"/*'' :&nbsp;IN_COMMENT }</dd>
</dl>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<p>
<em>// When a */ is seen in the IN_COMMENT&nbsp;state, switch back to the
DEFAULT state</em>
<p>
 &lt; IN_COMMENT &gt; <b>SKIP</b> : {

<p>

<dl compact="compact">

	<dd>"*/'' : DEFAULT }</dd>
</dl>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<p>
<em>// When any other character is seen in the IN_COMMENT&nbsp;state, skip it.</em>
<p>
 &lt; IN_COMMENT &gt; <b>SKIP</b> : {

<p>

<dl compact="compact">

	<dd> &lt; &nbsp;~[]
 &gt; }</dd>
</dl>
</TD></TR></TABLE></font>

<p>
 <h2><a name="tth_sEc3.8">
3.8</a>&nbsp;&nbsp;Why do the example Java and C++ parsers report an error when the last
line of a file is a single line comment?</h2>

<p>
The file is likely missing a newline character (or the equivalent)&nbsp;at the end
of the last line.

<p>
These parsers use lexical states and MORE type regular expression productions
to process single line comments thusly:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>MORE</b> : {

<p>

<dl compact="compact">

	<dd>"//'' : IN_SINGLE_LINE_COMMENT }</dd>
</dl>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<p>
 &lt; IN_SINGLE_LINE_COMMENT &gt; <b>SPECIAL_TOKEN</b> : {

<p>

<dl compact="compact">

	<dd> &lt; SINGLE_LINE_COMMENT:
"\n''
<font face="symbol">|</font
>"\r''
<font face="symbol">|</font
>"\r\n''
 &gt; : DEFAULT }</dd>
</dl>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<p>
 &lt; IN_SINGLE_LINE_COMMENT &gt; <b>MORE</b>&nbsp;:&nbsp;{

<p>

<dl compact="compact">

	<dd> &lt; &nbsp;~[]
 &gt; }</dd>
</dl>
</TD></TR></TABLE></font>

<p>
Clearly if an EOF is encountered while the token manager is still looking for
more of the current token, there should be a TokenMgrError thrown.

<p>
Both the Java and the C++ standards agree with the example .jj files, but some
compilers are more liberal and do not insist on that final newline. If you
want the more liberal interpretation, try

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>SPECIAL_TOKEN</b> : {

<p>

<dl compact="compact">

	<dd> &lt; SINGLE_LINE_COMMENT:
"//'' (~["\n'',"\r''])* ("\n''
<font face="symbol">|</font
>"\r''
<font face="symbol">|</font
>"\r\n'')?
 &gt; }</dd>
</dl>
</TD></TR></TABLE></font>

<p>
 <h2><a name="tth_sEc3.9">
3.9</a>&nbsp;&nbsp;What is a common token action?</h2>

<p>
A common token action is simply a subroutine that is called after each
<font face="helvetica">Token</font> is matched.

<p>
 <h2><a name="tth_sEc3.10">
3.10</a>&nbsp;&nbsp;How do I throw a ParseException instead of a TokenMgrError?</h2>

<p>
If you don't want any TokenMgrErrors being thrown, try putting a regular
expression production at the very end of your .jj file that will match any character:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
 &lt; * &gt; <b>TOKEN</b> :

<p>
{
<p>
 &lt; UNEXPECTED_CHAR : ~[]
 &gt; 
<p>
}
</TD></TR></TABLE></font>

<p>
However, this may not do the trick. In particular, if you use MORE, it may be
hard to avoid TokenMgrErrors altogether. It is best to make a policy of
catching TokenMgrErrors as well as ParseExceptions, whenever you call an entry
point to the parser.

<p>
 <h2><a name="tth_sEc3.11">
3.11</a>&nbsp;&nbsp;Why are line and column numbers not recorded?</h2>

<p>
In version 2.1 a new feature was introduced. You now have the option that the
line and column numbers will not be recorded in the Token objects. The option
is called <font face="helvetica">KEEP_LINE_COLUMN</font>. The default is <font face="helvetica">true</font>, so not
knowing about this option <em>shouldn't</em> hurt you.

<p>
However, there appears to be a bug in the GUI&nbsp;interface to JavaCC
(javaccw.exe), which sets this option to <font face="helvetica">false</font> (even if you
explicitly set it to <font face="helvetica">true</font> in the .jj file).

<p>
The solution is to delete <b>all</b> generated files (see
Question <a href="#option-changed">2.3</a>, "I changed option <i>x</i>; why am I
having trouble?'') and henceforth to not use the GUI&nbsp;interface to JavaCC.

<p>
 <h1><a name="tth_chAp4">
Chapter 4 </a><br />The Parser and Lookahead</h1>

<p>
 <h2><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Where should I draw the line between lexical analysis and parsing?</h2>

<p>
This question is dependant on the application. A lot of simple applications
only require a token manager. However, many people try to do too much with the
lexical analyzer, for example they try to write an expression parser using
only the lexical analyzer.

<p>
 <h2><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;What is recursive descent parsing?</h2>

<p>
JavaCC's generated parser classes work by the method of
"recursive descent''. This means that each BNF production nonterminal in the
.jj file is translated into a subroutine with roughly the following mandate:

<p>

<blockquote><em>If there is a prefix of the input sequence of tokens that matches this
nonterminal's definition,</em>

<p>
<em>then remove that prefix from the input sequence</em>

<p>
<em>else throw a ParseException</em>
</blockquote>

<p>
 <h2><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;What is left-recursion and why can't I use it?</h2>

<p>
Left-recursion is when a nonterminal contains a recursive reference to itself
that is not preceded by something that will consume tokens.

<p>
The parser class produced by JavaCC works by recursive descent. Left-recursion
is banned to prevent the generated subroutines from calling themselves
recursively ad-infinitum. Consider the following obviously left recursive production

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> A()&nbsp;: {} {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>A() B()</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>C()</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
 This will translate to a Java subroutine of the form

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> A()&nbsp;: {}&nbsp;{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><b>if</b>(&nbsp;<em>some condition</em> )&nbsp;{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>A() ;</dd>
 <dt><b></b></dt>
	<dd>B() ; }</dd>
</dl></dd>
 <dt><b></b></dt>
	<dd><b>else</b> {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>C() ; }</dd>
</dl></dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
Now if the condition is ever true, we have an infinite recursion.

<p>
 <h2><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;I get a message saying
"Warning: Choice Conflict ... ''; what should I do?</h2>

<p>
Some of JavaCC's most common error messages goes something like this

<p>

<blockquote><em>Warning:&nbsp;Choice conflict ...</em>

<p>
<em>Consider using a lookahead of 2 for ...</em>
</blockquote>

<p>
Read the message carefully. Understand why there is a choice conflict (choice
conflicts will be explained shortly) and take appropriate action. The
appropriate action, in my experience, is rarely to use a lookahead of 2.

<p>
So what is a choice conflict. Well suppose you have a BNF production

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> a()&nbsp;:&nbsp;{}&nbsp;{

<p>

<dl compact="compact">

	<dd> &lt; ID &gt; &nbsp;b()&nbsp;</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; ID &gt; &nbsp;c()</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
When the parser applies this production, it must choose between expanding it
to <font face="helvetica"> &lt; ID &gt; &nbsp;b()</font> and expanding it to <font face="helvetica"> &lt; ID &gt; &nbsp;c()</font>. The default method of making such choices is to look at the next
token. But if the next token is of kind <font face="helvetica">ID</font> then either choice is
appropriate. So you have a
"choice conflict''. For alternation (i.e.
<font face="symbol">|</font
>) the default choice is the first choice.

<p>
To resolve this choice conflict you can add a
"LOOKAHEAD specification'' to the first alternative. For example, if
nonterminal <font face="helvetica">b</font> and nonterminal <font face="helvetica">c</font> can be distinguished on the
basis of the token after the <font face="helvetica">ID</font> token, then the parser need only
lookahead 2 tokens. You tell JavaCC this by writing:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> a()&nbsp;:&nbsp;{}&nbsp;{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>LOOKAHEAD(&nbsp;2 )</dd>

	<dd>
 &lt; ID &gt; &nbsp;b()&nbsp;</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; ID &gt; &nbsp;c()</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
Ok but suppose that <font face="helvetica">b</font> and <font face="helvetica">c</font> can start out the same and are
only distinguished by how they end. No predetermined limit on the length of
the lookahead will do. In this case, you can use
"syntactic lookahead''. This means you have the parser look ahead to see if a
particular syntactic pattern is matched before committing to a choice.
Syntactic lookahead in this case would look like this:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> a()&nbsp;:&nbsp;{}&nbsp;{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><em>// Take the first alternative if an
 &lt; ID &gt; followed by a b() appears next</em></dd>
 <dt><b></b></dt>
	<dd>LOOKAHEAD(&nbsp; &lt; ID &gt; &nbsp;b() )</dd>

	<dd>
 &lt; ID &gt; &nbsp;b()&nbsp;</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; ID &gt; &nbsp;c()</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
Another way to resolve conflicts is to rewrite the grammar. The above
nonterminal can be rewritten as

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> a()&nbsp;:&nbsp;{}&nbsp;{

<p>

<dl compact="compact">

	<dd> &lt; ID &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>(

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>b()&nbsp;</dd>
</dl></dd>

	<dd>
<font face="symbol">|</font
>
<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>c()</dd>
</dl></dd>
 <dt><b></b></dt>
	<dd>)</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
 which resolves the conflict.

<p>
Choice conflicts also come up in loops. Consider

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> paramList()&nbsp;:&nbsp;{}&nbsp;{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>param()</dd>
 <dt><b></b></dt>
	<dd>(

<p>

<dl compact="compact">

	<dd> &lt; COMMA &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>param()</dd>
</dl></dd>
 <dt><b></b></dt>
	<dd>)*</dd>
 <dt><b></b></dt>
	<dd>(

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>( &lt; COMMA &gt; )?&nbsp; &lt; ELLIPSIS &gt; </dd>
</dl></dd>
 <dt><b></b></dt>
	<dd>)?</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
There is a choice of whether to stay in the * loop or to exit it and process
the optional <font face="helvetica">ELLIPSIS</font>. But the default method of making the choice
based on the next token does not work; a <font face="helvetica">COMMA</font> token could be the
first thing seen in the loop body, or it could be the first thing after the
loop body. For loops the default choice is to stay in the loop.

<p>
To solve this example we could use a lookahead of 2 at the appropriate choice
point (assuming a param can not be empty and that one can't start with an
<font face="helvetica">ELLIPSIS</font>.

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> paramList()&nbsp;:&nbsp;{}&nbsp;{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>param()</dd>
 <dt><b></b></dt>
	<dd>(

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>LOOKAHEAD(2)</dd>

	<dd>
 &lt; COMMA &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>param()</dd>
</dl></dd>
 <dt><b></b></dt>
	<dd>)*</dd>
 <dt><b></b></dt>
	<dd>(

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>( &lt; COMMA &gt; )?&nbsp; &lt; ELLIPSIS &gt; </dd>
</dl></dd>
 <dt><b></b></dt>
	<dd>)?</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
We could also rewrite the grammar, replacing the loop with a recursion.

<p>
Sometimes the right think to do is nothing. Consider this classical example
again from programming languages

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> statement()&nbsp;: {}

<p>
{

<p>

<dl compact="compact">

	<dd> &lt; IF &gt; &nbsp;exp()
 &lt; THEN &gt; &nbsp;statement()&nbsp;</dd>
 <dt><b></b></dt>
	<dd>(&nbsp; &lt; ELSE &gt; &nbsp;statement()&nbsp;)?</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><em>...other possible statements...</em></dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
Because an <font face="helvetica">ELSE</font> token could legitimately follow a <font face="helvetica">statement</font>,
there is a conflict. The fact that an <font face="helvetica">ELSE</font> appears next is not enough
to indicate that the optional
"<font face="helvetica"> &lt; ELSE &gt; &nbsp;statement()</font>'' should be parsed. Thus there is a conflict. The default for
parsers is to take an option rather than to leave it; and that turns out to be
the right interpretation in this case (at least for C, C++, Java, Pascal,
etc.). If you want, you can write:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> statement()&nbsp;: {}

<p>
{

<p>

<dl compact="compact">

	<dd> &lt; IF &gt; &nbsp;exp()
 &lt; THEN &gt; &nbsp;statement()&nbsp;</dd>
 <dt><b></b></dt>
	<dd>(&nbsp;LOOKAHEAD(&nbsp; &lt; ELSE &gt; )&nbsp; &lt; ELSE &gt; &nbsp;statement()&nbsp;)?</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><em>...other possible statements...</em></dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
 to suppress the warning.

<p>
If you use LOOKAHEAD, please read the lookahead mini-tutorial in
the JavaCC&nbsp;documentation. (See Section<a href="#javacc-doc">2.1</a>).

<p>
 <h2><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;I&nbsp;added a LOOKAHEAD specification and the warning went away; does
that mean I&nbsp;fixed the problem?</h2>

<p>
No. JavaCC&nbsp;will not report choice conflict warnings if you use a LOOKAHEAD
specification. The absence of a warning doesn't mean that you've solved the
problem correctly, it just means that you added a LOOKAHEAD specification.

<p>
Consider the following example:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> eg()&nbsp;: {}

<p>
{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>LOOKAHEAD(2)</dd>

	<dd>
 &lt; A &gt; &nbsp; &lt; B &gt; &nbsp; &lt; C &gt; </dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; A &gt; &nbsp; &lt; B &gt; &nbsp; &lt; D &gt; </dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
Clearly the lookahead is insufficient (lookahead 3 would do the trick), but
JavaCC produces no warning. When you add a&nbsp;LOOKAHEAD specification, JavaCC
assumes you know what you are doing and suppresses any warnings.

<p>
 <h2><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;Are semantic actions executed during syntactic lookahead?</h2>

<p>
No.

<p>
 <h2><a name="tth_sEc4.7">
4.7</a>&nbsp;&nbsp;Is semantic lookahead evaluated during syntactic lookahead?</h2>

<p>
Yes, it should be.

<p>
 <h2><a name="tth_sEc4.8">
4.8</a>&nbsp;&nbsp;How does JavaCC differ from standard LL(1) parsing?</h2>

<p>
Well first off JavaCC is more flexible. It lets you use multiple token
lookahead, syntactic lookahead, and semantic lookahead. If you don't use these
features, you'll find that JavaCC is only subtly different from
LL(1)&nbsp;parsing; it does not calculate
"follow sets'' in the standard way - in fact it can't as JavaCC has no idea
what your starting nonterminal will be.

<p>
 <h2><a name="tth_sEc4.9">
4.9</a>&nbsp;&nbsp;How do I communicate from the parser to the token manager?</h2>

<p>
It is usually a bad idea to try to have the parser try to influence the way
the token manager does its job. The reason is that the token manager may
produce tokens long before the parser needs them. This is a result of lookahead.

<p>
Often the work-around is to use lexical states to have the token manager
change its behaviour on its own.

<p>
In other cases, the work-around is to have the token manager not change its
bevhaviour and have the parser compensate. For example in parsing C, you need
to know if an identifier is a type or not. Suppose you have written your
parser in terms of token kinds ID and TYPEDEF_NAME. Using lex and yacc, the
solution is to have the parser add typedef names to the symbol table and have
the lexical analyzer look up identifiers in the symbol table to decide which
token kind to use. (This works because with lex and yacc, the lexical analyzer
is always one token ahead of the parser.) In JavaCC, it is better to just use
one token kind, ID, and use a nonterminal in place of TYPEDEF_NAME:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> typedef_name() : {} {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>LOOKAHEAD(
 &lt; ID &gt; , { symtab.isTypedefName( getToken(0).image ) } )</dd>

	<dd>
 &lt; ID &gt; }</dd>
</dl>
</TD></TR></TABLE></font>

<p>
But you have to be careful using semantic look-ahead like this. It could still
cause trouble. Consider doing a syntactic lookahead on nonterminal
`<font face="helvetica">statement'</font>. If the next statement is something like

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
{ typedef int T ; T i ; i = 0 ; return i ; }
</TD></TR></TABLE></font>

<p>
The lookahead will fail since the semantic action putting T in the symbol
table will not be done during the lookahead!

<p>
 <h2><a name="tth_sEc4.10">
4.10</a>&nbsp;&nbsp;How do I communicate from the token manager to the parser?</h2>

<p>
As with communication between from the parser to the token manager, this can
be tricky because the token manager is often well ahead of the parser.

<p>
For example, if you calculate the value associated with a particular token
kind in the token manager and store that value in a simple variable, that
variable may well be overwritten by the time the parser consumes the relevant
token. Instead you can use a queue. The token manager puts information into
the queue and the parser takes it out.

<p>
Another solution is to use a table. For example in dealing with
<tt>#line</tt> directives in C or C++, you can have the token manager fill a
table indicating on which physical lines the<font face="helvetica">&nbsp;</font><tt>#line</tt>
directives occur and what the value given by the <tt>#line</tt> is. Then the
parser can use this table to calculate the
"source line number'' from the physical line numbers stored in the Tokens.

<p>
 <h2><a name="tth_sEc4.11">
4.11</a>&nbsp;&nbsp;What does it mean to put a regular expression within a
BNF&nbsp;production?<A NAME="what-means-reg-exp-in-bnf"></A></h2>

<p>
It is possible to embed a regular expression within a BNF&nbsp;production. For example

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<em>//A regular expression production</em>

<p>
<b>TOKEN</b>&nbsp;: {&nbsp; &lt; ABC :&nbsp;"abc''&nbsp; &gt; }

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<p>
<em>//A BNF production</em>

<p>
<b>void</b> nonterm()&nbsp;:&nbsp;{}&nbsp;{

<p>

<dl compact="compact">

	<dd>"abc''</dd>

	<dd>
"def''</dd>

	<dd>
 &lt; (["0''-"9''])+ &gt; 
<p>
</dd>

	<dd>"abc''</dd>

	<dd>
"def''</dd>

	<dd>
 &lt; (["0''-"9''])+ &gt; </dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
There are six regular expressions within the BNF&nbsp;production. The first is
simply a Java string and is the same string that appears in the earlier
regular expression production. The second is simply a Java string, but does
not (we will assume) appear in a regular expression production. The third is
a
"complex regular'' expression. The next three simply duplicate the first three.

<p>
The code above is essentially equivalent to the following:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<em>//A regular expression production</em>

<p>
<b>TOKEN</b>&nbsp;: {&nbsp; &lt; ABC :&nbsp;"abc''&nbsp; &gt; }

<p>
<b>TOKEN</b>&nbsp;: {&nbsp; &lt; ANON0 :&nbsp;"def''&nbsp; &gt; }

<p>
<b>TOKEN</b>&nbsp;: {&nbsp; &lt; ANON1 :&nbsp; &lt; (["0''-"9''])+ &gt; }

<p>
<b>TOKEN</b>&nbsp;: {&nbsp; &lt; ANON2 :&nbsp; &lt; (["0''-"9''])+ &gt; }

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<p>
<em>//A BNF production</em>

<p>
<b>void</b> nonterm()&nbsp;:&nbsp;{}

<p>
{

<p>

<dl compact="compact">

	<dd> &lt; ABC &gt; 
<p>
</dd>

	<dd> &lt; ANON0 &gt; 
<p>
</dd>

	<dd> &lt; ANON1 &gt; 
<p>
 &lt; ABC &gt; 
<p>
</dd>

	<dd> &lt; ANON0 &gt; 
<p>
</dd>

	<dd> &lt; ANON2 &gt; </dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
In general when a regular expression is a Java string and identical to regular
expression occurring in a regular expression production<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>, then the Java
string is interchangeable with the token kind from the regular expression production.

<p>
When a regular expression is a Java string, but there is no corresponding
regular expression production, then JavaCC essentially makes up a
corresponding regular expression production. This is shown by the <font face="helvetica">"def''</font> which becomes an anonymous regular expression production. Note that all
occurrences of the same string end up represented by a single regular
expression production.

<p>
Finally consider the two occurrences of the complex regular expression
<font face="helvetica"> &lt; (["0''-"9''])+ &gt; </font>. Each one is turned into a different regular expression production. This
spells trouble, as the <font face="helvetica">ANON2</font> regular expression production will never
succeed. (See
Question <a href="#more-than-one">3.3</a>. "What if more than one regular
expression matches a prefix of the remaining input?'')

<p>
See also
Question <a href="#when-reg-exp-in-bnf">4.12</a>, "When should regular
expressions be put directly into a BNF&nbsp;production?''.

<p>
 <h2><a name="tth_sEc4.12">
4.12</a>&nbsp;&nbsp;When should regular expressions be put directly into a
BNF&nbsp;production?<A NAME="when-reg-exp-in-bnf"></A></h2>

<p>
First read
Question <a href="#what-means-reg-exp-in-bnf">4.11</a>, "What does it mean to put
a regular expression within a BNF&nbsp;production?''.

<p>
For regular expressions that are simply strings, you might as well put them
directly into the BNF&nbsp;productions, and not bother with defining them in a
regular expression production.<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a> For more complex regular expressions, it is best to give them a
name, using a regular expression production. There are two reasons for this.
The first is error reporting. If you give the regular expression a name, that
name will be used in the message attached to any ParseExceptions generated. If
you don't give it a name, JavaCC will make up a name like
" &lt; token of kind 42 &gt; ''. The second is perspicuity. Consider the following example:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> letter_number_letters()&nbsp;:&nbsp;{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>Token letter, number, letters; }</dd>
</dl>

<p>
{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>letter= &lt; ["a''-"z''] &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>number= &lt; ["0''-"9''] &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>letters= &lt; (["a''-"z''])+ &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>{&nbsp;<b>return</b> <em>some function of letter, number and letters</em> ; }</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
The intention is to be able to parse strings like
"<tt>a9abc</tt>''. Written this way it is a bit hard to see what is wrong.
Rewrite it as

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>TOKEN</b>&nbsp;:&nbsp; &lt; &nbsp;LETTER&nbsp;:&nbsp;["a''-"z'']
 &gt; }

<p>
<b>TOKEN</b>&nbsp;:&nbsp; &lt; &nbsp;LETTER&nbsp;: ["0''-"9'']
 &gt; }

<p>
<b>TOKEN</b>&nbsp;:&nbsp; &lt; &nbsp;LETTERS&nbsp;:&nbsp;(["a''-"z''])+
 &gt; }

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<p>
<b>void</b> letter_number_letters()&nbsp;:&nbsp;{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>Token letter, number, letters; }</dd>
</dl>

<p>
{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>letter= &lt; LETTER &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>number= &lt; NUMBER &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>letters= &lt; LETTERS &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>{&nbsp;<b>return</b> <em>some function of letter, number and letters</em> ; }</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
 and it might be easier to see the error. On a string like
"<tt>z7d</tt>'' the token manager will find a <font face="helvetica">LETTER</font>, a
<font face="helvetica">NUMBER</font> and then another <font face="helvetica">LETTER</font>; the BNF&nbsp;production can not
succeed. (See
Question <a href="#more-than-one">3.3</a>, "What if more than one regular
expression matches a prefix of the remaining input?'')

<p>
 <h2><a name="tth_sEc4.13">
4.13</a>&nbsp;&nbsp;How do I parse a sequence without allowing duplications?</h2>

<p>
This turns out to be a bit tricky. Of course you can list all the alteratives.
Say you want A, B, C, each optionally, in any order, with no duplications;
well there are only 16 possibilities:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> abc()&nbsp;:&nbsp;{} {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>[ &lt; A &gt; &nbsp;[
 &lt; B &gt; &nbsp;[
 &lt; C &gt; &nbsp;] ] ]</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; A &gt; &nbsp; &lt; C &gt; [
 &lt; B &gt; &nbsp;]</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; B &gt; &nbsp;[
 &lt; A &gt; &nbsp;[
 &lt; C &gt; &nbsp;] ]</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; B &gt; &nbsp; &lt; C &gt; [
 &lt; A &gt; &nbsp;]</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; C &gt; &nbsp;[
 &lt; A &gt; &nbsp;[
 &lt; B &gt; &nbsp;] ]</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; C &gt; &nbsp; &lt; B &gt; &nbsp;[&nbsp; &lt; A &gt; &nbsp;]</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
 This approach is already ugly and won't scale.

<p>
A better approach is to use semantic actions to record what has been seen

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> abc()&nbsp;:&nbsp;{}&nbsp;{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>(

<p>

<dl compact="compact">

	<dd> &lt; A &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>{ if(&nbsp;<em>seen an A already</em> ) throw ParseException("Duplicate A'');</dd>
 <dt><b></b></dt>
	<dd>else <em>record an A</em> }</dd>
</dl></dd>

	<dd>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; B &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>{ if(&nbsp;<em>seen an B already</em> ) throw ParseException("Duplicate B'');</dd>
 <dt><b></b></dt>
	<dd>else <em>record an B</em> }</dd>
</dl></dd>

	<dd>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; C &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>{ if(&nbsp;<em>seen an C already</em> ) throw ParseException("Duplicate C'');</dd>
 <dt><b></b></dt>
	<dd>else <em>record an C</em> }</dd>
</dl></dd>
 <dt><b></b></dt>
	<dd>)*</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
The problem with this approach is that it will not work well with syntactic
lookahead. Ninety-nine percent of the time you won't care about this problem,
but consider the following highly contrived example:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>void</b> toughChoice()&nbsp;:&nbsp;{}

<p>
{

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>LOOKAHEAD(&nbsp;abc()&nbsp;)</dd>
 <dt><b></b></dt>
	<dd>abc()&nbsp;</dd>
</dl>
<p>
<font face="symbol">|</font
>
<p>

<dl compact="compact">

	<dd> &lt; A &gt; &nbsp; &lt; A &gt; &nbsp; &lt; B &gt; &nbsp; &lt; B &gt; </dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
When the input is two <font face="helvetica">A</font>'s followed by two <font face="helvetica">B</font>'s, the second
choice should be taken. If you use the first (ugly) version of <font face="helvetica">abc</font>,
above, then that's what happens. If you use the second (nice) version of
<font face="helvetica">abc</font>, then the first choice is taken, since syntactically <font face="helvetica">abc</font>
is <font face="helvetica">( &lt; A &gt; &nbsp;<font face="symbol">|</font
>&nbsp; &lt; B &gt; &nbsp;<font face="symbol">|</font
>&nbsp; &lt; C &gt; )*.</font>

<p>
 <h2><a name="tth_sEc4.14">
4.14</a>&nbsp;&nbsp;There's an error in the input, so why doesn't my parser throw a ParseException?</h2>

<p>
Perhaps you forgot the <font face="helvetica"> &lt; EOF &gt; </font> in the production for your start nonterminal.

<p>
 <h1><a name="tth_chAp5">
Chapter 5 </a><br />Semantic Actions</h1>

<p>
 <h2><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;I've written/found a parser, but it doesn't do anything?</h2>

<p>
You need to add semantic actions. Semantic actions are bits of Java code that
get executed as the parser parses.

<p>
 <h2><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;How do I capture and traverse a sequence of tokens?</h2>

<p>
Each Token object has a pointer to the next Token object. Well that's not
quite right. There are two kinds of Token objects. There are regular token
objects, created by regular expression productions prefixed by the keyword
<font face="helvetica">TOKEN</font>. And, there are special token objects, created by regular
expression productions prefixed by the keyword <font face="helvetica">SPECIAL_TOKEN</font>. Each
regular Token object has a pointer to the next regular Token object. We'll
deal with the special tokens later.

<p>
Now since the tokens are nicely linked into a list, we can represent a
sequence of tokens occurring in the document with a class by pointing to the
first token in the sequence and the first token to follow the sequence.

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>class</b> TokenList {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><b>private</b> Token head ;</dd>
 <dt><b></b></dt>
	<dd><b>private</b> Token tail ;</dd>
</dl>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>TokenList( Token head, Token tail ) {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>this.head = head ;</dd>
 <dt><b></b></dt>
	<dd>this.tail = tail ; }</dd>
</dl></dd>
 <dt><b></b></dt>
	<dd>...</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
We can create such a list based using semantic actions in the parser like this:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
TokenList CompilationUnit() : {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>Token head ;</dd>
</dl>

<p>
} {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>{ head = getToken( 1 ) ; }</dd>
 <dt><b></b></dt>
	<dd>[ PackageDeclaration() ] ( ImportDeclaration() )* ( TypeDeclaration() )*</dd>

	<dd>
 &lt; EOF &gt; 
<p>
</dd>
 <dt><b></b></dt>
	<dd>{&nbsp;return new TokenList( head, getToken(0) ) ; }</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
To print regular tokens in the list, we can simply traverse the list

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>class</b> TokenList {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>...</dd>
 <dt><b></b></dt>
	<dd><b>void</b> print( PrintStream os ) {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><b>for</b>( Token p = head ; p != tail ; p = p.next ) {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>os.print( p.image ) ; } }</dd>
</dl></dd>
</dl></dd>
 <dt><b></b></dt>
	<dd>...</dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
This method of traversing the list of tokens is appropriate for many applications.

<p>
Here is some of what I&nbsp;got from printing the tokens of a Java file:
<p>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<tt>publicclassToken</tt>{<tt>publicintkind</tt><tt>;</tt><tt>publicintbeginLine</tt><tt>,</tt></td></tr></table>
</td></tr></table>


Obviously this is not much good for either human or machine consumption. I
could just print a space between each pair of adjacent tokens. A nicer
solution is to capture all the spaces and comments using special tokens. Each
<font face="helvetica">Token</font> object (whether regular or special) has a field called
<font face="helvetica">specialToken</font>, which points to the special token that appeared in the
text immediately prior, if there was one, and is null otherwise. So prior to
printing the image of each token, we print the image of the preceding special
token, if any:

<p>
<font face="helvetica"><TABLE WIDTH="80%" BORDER="2" BGCOLOR="FFFFCC"><TR><TD>
<b>class</b> TokenList {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>...</dd>
 <dt><b></b></dt>
	<dd><b>private</b> <b>void</b> printSpecialTokens( PrintStream ps, Token
st ) {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><b>if</b>( st != null ) {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>printSpecialTokens( ps, st.specialToken ) ;</dd>
 <dt><b></b></dt>
	<dd>ps.print( st.image ) ; } }</dd>
</dl></dd>
</dl></dd>
</dl>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><b>void</b> printWithSpecials( PrintStream ps ) {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd><b>for</b>( Token p = head ; p != tail ; p = p.next ) {

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>printSpecialTokens( ps, p.specialToken ) ;</dd>
 <dt><b></b></dt>
	<dd>ps.print( p.image ) ; } }</dd>
</dl></dd>
</dl></dd>
</dl>

<p>
}
</TD></TR></TABLE></font>

<p>
If you want to capture and print a whole file, don't forget about the special
tokens that precede the <font face="helvetica">EOF</font> token.

<p>
 <h1><a name="tth_chAp6">
Chapter 6 </a><br />JJTree and JTB<A NAME="jjtree-and-jtb"></A></h1>

<p>
TBD. Your maintainer knows little about either of these tools and would
especially appreciate volunteers to contribute to this part of the FAQ.

<p>
 <h2><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;What are JJTree and JTB</h2>

<p>
These are preprocessors that produce .jj files. The .jj files produced will
produce parsers that produce trees.

<p>
 <h2><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Where can I&nbsp;find JJTree</h2>

<p>
JJTree comes with JavaCC. See
Question <a href="#where-is-javacc">1.8</a>, "Where can I&nbsp;get JavaCC?''..

<p>
 <h2><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Where can I find JTB</h2>

<p>
See
<A href="http://www.cs.purdue.edu/jtb/">JTB: The Java Tree Builder Homepage</A>..

<p>
 <h1><a name="tth_chAp7">
Chapter 7 </a><br />Applications of JavaCC</h1>

<p>
 <h2><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Where can I find a parser for <i>x</i>.</h2>

<p>
First look in Dongwon Lee's
<A href="http://www.cobase.cs.ucla.edu/pub/javacc/">JavaCC Grammar Repository</A>.

<p>
Then ask the newsgroup or the mailing list.

<p>
 <h2><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;How do I parse arithmetic expressions?</h2>

<p>
See the examples that come with JavaCC.

<p>
See any text on compiling.

<p>
See
<A href="http://www.engr.mun.ca/~theo/Misc/index.html#parsingExps">Parsing Epressions by Recursive Descent</A>.

<p>
 <h2><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;I'm writing a programming language interpreter; how do I deal with loops?</h2>

<p>
A lot of people who want to write an interpreter seem to start with a
calculator for expressions, evaluating during parsing, as is quite reasonable.
Then they add assignments and if-then-else statements and all goes well. Now
they want to add loops. Having committed to the idea that they are evaluating
while parsing they want to somehow back up the token manager so that the
loop-body can be parsed, and thus evaluated, over and over and over again.

<p>
It's an interesting idea, but it's clear that JavaCC will not make this
approach pleasant. Your maintainer suggests translating to an intermediate
code during parsing, and then executing the intermediate code. A tree makes a
convenient intermediate code. Consider using JJTree or JTB (see
Chapter <a href="#jjtree-and-jtb">6</a>).
<hr /><h3>Footnotes:</h3>

<p>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Another way of looking at it is
that JavaCC is of little help in this regard. However, if you want to produce
trees there are two tools, based on JavaCC, that are less flexible and more
helpful, these are
JJTree and JTB. See Chapter <a href="#jjtree-and-jtb">6</a>.
<p>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>JavaCC's terminology here is a bit unusual. The
conventional name for what JavaCC calls a ``token kind'' is ``terminal'' and
the set of all token kinds is the ``alphabet'' of the EBNF&nbsp;grammar.
<p>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>And provided
that regular expression applies in the DEFAULT lexical state.
<p>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>Ok there are still a few reasons to
use a regular expression production. One is if you are using lexical states
other than DEFAULT. Another is if you want to ignore the case of a word. Also,
some people just like to have an alphabetical list of their keywords
somewhere.
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.03.<br />On  7 Dec 2001, 13:09.</small>
</html>
