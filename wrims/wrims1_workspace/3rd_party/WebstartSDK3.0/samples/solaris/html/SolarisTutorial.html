<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>WebStart Wizard SDK Tutorial for Solaris Users</title>
  </head>

  <body bgcolor="#FFFFFF">
    <center>
      <h1>WebStart Wizard SDK Tutorial for Solaris Users</h1>
      <p>
	</center>
      <hr>
      <h2>CONTENTS</h2>
      <blockquote>
	  <ol>
	    <li><h3><a href="#Webstart Wizards on Solaris">Introduction: Webstart Install Wizards on Solaris</a></h3></li>
      <ul>
	  <li><h5><a href="#installvsconfig">Install vs. Configuration Wizards</a></h5>
      </ul>
	  <li><h3><a href="#How to package">How should I package my product?</a></h3>
	  <ul>
	  <li><h5><a href="#SVR4">Products With Solaris SVR4 Packages</a></h5>
	  <li><h5><a href="#Patches">Products With Solaris Patches</a></h5>
	  <li><h5><a href="#Standalone">Products With standalone files</a></h5>
	  <li><h5><a href="#System Dependencies">Products With System Environment Dependencies</a></h5>
	  <li><h5><a href="#PrePost-Install">Products Which Required Pre- or Post-Installation Configuration</a></h5>
	  <li><h5><a href="#CDROM">Laying out your product on a CD-ROM</a></h5>
	  <li><h5><a href="#PackageTogether">Putting It All Together</a></h5>
	</ul>
	</li>
	  <li><h3><a href="#Code">What code do I need to write?</a></h3>
	  <ul>
	    <li><h5><a href="#CodeDevEnv">Creating a development environment</a></h5>
	    <li><h5><a href="#CodeBuilder">Writing the Builder</a></h5>
	  <li><h5><a href="#CodePanels">Creating Pre- and Post-Install User Interface Panels</a></h5>
	  <li><h5><a href="#CodeTogether">Putting It All Together</a></h5>
	</ul>
	</li>
	  <li><h3><a href="#SolarisBuilder">Solaris Step-By-Step Example: SolarisBuilder.java</a></h3>
	  <ul>
	    <li><h5><a href="#Sample Files">Sample Files Involved</a></h5></li>
	  <li><h5><a href="#Step 1">Step 1: Layout out the Product Tree</a></h5></li>
	  <li><h5><a href="#Step 2">Step 2: Begin the Builder</a></h5></li>
	  <li><h5><a href="#Step 3">Step 3: Set the Product Name and Default Directory</a></h5></li>
	  <li><h5><a href="#Step 4">Step 4: Set the Images to Display</a></h5></li>
	  <li><h5><a href="#Step 5">Step 5: Set any Configurable Messages</a></h5></li>
	  <li><h5><a href="#Step 6">Step 6: Build the Product Components</a></h5></li>
	  <li><h5><a href="#Step 7">Step 7: Create Platform Objects </a></h5></li>
	  <li><h5><a href="#Step 8">Step 8: Create Platform Dependencies</a></h5></li>
	  <li><h5><a href="#Step 9">Step 9: Create Solaris Patch Components</a></h5></li>
	  <li><h5><a href="#Step 10">Step 10: Create Solaris Package Components</a></h5></li>
	  <li><h5><a href="#Step 11">Step 11: Build the Product Tree</a></h5></li>
	  <li><h5><a href="#Step 12">Step 12: Create Configuration Panels</a></h5></li>
	  <li><h5><a href="#Step 13">Step 13: Finish the Builder</a></h5></li>
	  <li><h5><a href="#Step 14">Step 14: Compile & Run the Builder & Wizard</a></h5></li>
	</ul>
	</li>
      </blockquote>
      <hr>
      <h3><a name="Webstart Wizards on Solaris">1. Introduction: Webstart Install Wizards on Solaris</a></h3>
      <blockquote>
	  It is easy to create a Webstart Install Wizard for
	  installing products on Solaris. Many products targeted for
	  Solaris are complex and involve installation, configuration,
	  and testing.  Through the use of a Webstart Wizard, you can
	  be sure that your product will get installed correctly and
	  easily, without any confusion.  
	  <p>
	    Webstart Wizards make Solaris-specific installers
	    through the support of Solaris SVR4 Packages and Solaris
	    Patches.  You can create a <em>product tree</em> of packages and patches,
	    and have the Wizard install using this tree as a description
	    of what to install.  Your tree can be built to be architecture-independent,
	    so that it works on all Solaris implementations, regardless of the architecture
	    of the underlying machine.
	<ul>
	<li><h5><a name="installvsconfig">Install vs. Configuration Wizards</a></h5>
	  <p>
	    The generic Wizard API allows you to create any type of
	    wizard, including install wizards that install a software
	    product, or a configuration wizard which configures a
	    previously-installed product.  <strong><em>However, you should
	    not combine these functions into a single wizard, since
	    the install wizard is intended to be run only once, but
	    the configuration wizard might be run several times during
	    the lifetime of the installed product. </strong></em>
	<p>
	    If you would like to build wizard-style configuration into
	    your product, you must build a separate wizard that can
	    configure your product, and point your users to the wizard
	    and how to run it once they install the product.
	    <p>

      </blockquote>
      <h3><a name="How to package">2. How should I package my product?</h3>
      <blockquote>
	  If your product already has an installation mechanism for
	  Solaris (such as SVR4 Packages), creating a builder to
	  install your product will be almost trivial.  For new
	  products that you are creating an installer for, any
	  combination of Solaris SVR4 packages & patches and bare files
	  can be installed using Webstart Wizards.  <strong><em>However, Solaris
	  SVR4 packages & patches are the only official way of distributing 
          software on the Solaris platform.  You should use Packages and Patches 
	  so that Solaris can recognize and register your 
	  product's files with the system.</em></strong>
	  <p>
	    Each type of
	  collection is explained in further detail below. You can even
	  write support for your own custom type of files using the Wizard
	  API (see the <a href="../../../docs/api/com.sun.install.products.InstallLeaf.html">InstallLeaf</a>
	  API).  You can
	  also find examples of each type of collection in the example
	  provided.  See <a
	  href="../src/SolarisBuilder.java">SolarisBuilder.java</a>
	  for the source code to this sample.
      </blockquote>
	  <p>
	  <ul>
	    <li><h5><a name="Standalone">Products with standalone files</a></h5> 
	  Use this method if some files of your product
	  are not packaged in any predefined format, such as Solaris
	  Packages, Zip files, tar files, etc.  When you create your
	  wizard, the files you specify will be gathered up and placed
	  into the archive.  You can define any directory structure
	  you want, so that the files get written to their correct
	  destination directories when the wizard is run.  You might
	  also use this for miscellaneous files, such as READMEs, help
	  files, or other files that do not belong anywhere else.  In
	  fact, this is the method used to write the entire Webstart
	  Wizard SDK (see <a href="../../generic/src/WebstartSDKBuilder.java">WebstartSDKBuilder.java</a>,
	  the code used to create the SDK you have just installed).
	  <p>
	    <li><h5><a name="SVR4">Products with Solaris SVR4 Packages</h5> 
	  Products that are packaged within Solaris
	  SVR4 packages are easily installed using Webstart Wizards.
	  For information on creating Solaris SVR4 packages, see the
	  <em>pkgmk(1)</em> man page.  To install Solaris SVR4 Packages,
          you will use the <a href="../../../docs/api/com.sun.install.products.PkgUnit.html"><code>PkgUnit</code></a>class.
          There is some extra
	  information you must provide to a <code>PkgUnit</code> so that it can
	  cleanly install your packages. This information is provided
	  at buildtime in your builder code.  <strong> Please see <a href="../../../docs/api/com.sun.install.products.PkgUnit.html">
         the API documentation for the PkgUnit class</a> for information regarding how to specify a Package.</strong> 
	  <p>
	  <li><h5><a name="Patches">Products with Solaris Patches</h5>
	  If your product contains patches, Webstart Wizards can apply
	  those patches as part of the installation.  Often, a product
	  requires patches to be applied before it can install the
	  rest of the product, or the product might require the
	  patches before it can be run.  In either case, you would
	  want to force the installation to apply the patches by
	  making it a <em>required</em> product component consisting of
	  Solaris Patches.  This is done in the SolarisBuilder below,
         in order to force
	  certain patches to be applied.  
	  <p>
	    The only information you need to supply in your builder is
	    the relative path to the patch, and the revision.  For example
	    <code>../patches</code> as the relative path, and <code>102341-03</code>
          as the revision.  The patch is applied to the
	   system, and backup copies of the files being patched are made.
          <p>
	  <li><h5><a name="System Dependencies">Products with System Environment Dependencies</h5>
          Used for products which require certain conditions before
          they can be installed.  Example conditions might include a
          check of the processor type, a check for the Sun JDK
          installed on the system, or any other measurable variable.
          The SolarisBuilder below uses product tree
          dependencies.  Another way to check dependencies is during
          initialization, by adding a dependency task to the
          initialization Sequence (via <code>addInitializationTask()</code> within
          your builder).
          <p>
	  <li><h5><a name="PrePost-Install">Products Which Required
	  Pre- or Post-Installation Configuration</h5> Many products
	  might require extra customization before or after
	  installation, over and above the standard <code>"Product
	  Installation Directory:"</code> question.  With wizards, you
	  can create a series of user interface panels that gather
	  user customization information that you use to affect the
	  outcome of the install.  Or, you could have a series of
	  panels that customizes the product <em>after</em>
	  installation, without the user having to go edit text files,
	  or run other utilities to finish the installation and
	  configuration of the product.  You can then install these panels
	  within the panel sequence of your wizard to present to the user
	  before or after installation.  There is an API to add these panels
	  in the Wizard API, see the SolarisBuilder below for an 
	  example of a pre-install panel.
	  <p>
	  <li><h5><a name="CDROM">Layout Out Your Product on a CD-ROM</a></h5> 
          A good layout can help the user install the CD more
          easily. Suggesting a common layout for CDs also helps the
          user find files of interest from CD to CD and helps a
          company build a well-organized CD for global
          localization. Note the top level directory is kept
          simple. In a graphical context, this aids the user in finding the
          installer icon quickly and "double clicking" it to start the
          Web Start install.  For your product(s), you should use the 
          following directory layout when organizing your product on a CD-ROM:
      <p>
	<img src="images/CDFilesystem.gif" ALT="Picture of a CD-ROM Filesystem Layout" BORDER=0>
      <p>
	  The top-level <code>.install</code> directory contains a
	  CD-level wizard that is capable of presenting a single
	  install for all of the products on the CD.  In addition, the
	  <code>installer</code> script is located in the root
	  directory, which should run the install wizard.  This is
	  provided so that users can easily locate and run the
	  install. There is a sample installer script (written in korn shell)
	  located in the <code>samples</code> directory.  It has been used at Sun
	  to ship several multi-product CDs and can work for your product.
	<p>
	  Each of the {<strong>product1</strong>,
	  <strong>product2</strong>, <strong>. . . .</strong>,
	  <strong>productN</strong>} directories contains all of the
	  products to be installed with the CD-level installer, along
	  with supporting files.  Supporting files include another
	  <strong>installer</strong> script that runs the
	  product-level install (a wizard that only installs one
	  product), the install wizard itself, the supporting
	  localized resources, and the packages that make up the
	  product.
	<p>
	  You should use this layout for all CDs you install with Web Start Wizards.
	<p>
	  <li><h5><a name="PackageTogether">Putting it all together</a></h5>
	  In summary, your product can consist of virtually any combination of types
	  of files.  For file types that are not included in the Wizard SDK, java
	  classes can be written and used in order to support them.  See the <a href=
	    "../../../docs/api/com.sun.install.products.InstallLeaf.html">InstallLeaf</a> API
	  documentation for details on creating your own types of files.
	</ul>
	  <h3><a name="Code">3. What Code Do I Need To Write?</h3>
      <blockquote>
	For simple install wizards, the only thing you need to write is the <em>builder</em>
	  code.  This is where you will specify the files that comprise your product.  You
	  can also customize various aspects of the install, such as the "About..." message
	  contents, the exit warning, etc.  The rest of the install is written for you in the
	  <code>InstallArchiveWriter</code> class. A basic set of panels are provided for your wizard.
	  The panel sequence is as follows:
          <ul>
	    <li>1. Welcome (With optional "About..." Dialog)
	    <li>2. Install Type ("Typical" or "Custom") 
	    <li>3. Locale Selection (if the user selected a "Custom" install) 
	    <li>4. Directory Selection (if the user selected a "Custom" install) 
	    <li>5. Component Selection (if the user selected a "Custom" install) 
	    <li>6. Verify Panel (Shows user what they selected)
	    <li>7. Progress Panel (product actually gets installed here)
	    <li>8. Summary Panel (shows results)
	  </ul>
	  <p>
	    For more complex installs, you would need to build your
	    product tree yourself, as well as configure the wizard panel tree.
	    This is what we will be doing in the SolarisBuilder
	    below.  The basic steps to creating a wizard are:
	    <ul>
	    <li>1. Creating a development environment, 
	    <li>2. Writing a builder, 
	    <li>3. Creating pre- and post-installation configuration panels, and then 
	    <li>4. Compiling and running your builder.
	      </ul>
	    <p>
	    </blockquote>
	    <ul>
	    <li><h5><a name="CodeDevEnv">Creating a Development Environment</a></h5> 
            For developing wizards, a Sun JDK 1.1-compliant compiler is required.
            <p>
            It is recommended that you put any of your
	    supporting java <code>.class</code> files in a separate
	    package from the Webstart Wizards SDK classes.  You
	    should, however, include the Webstart Wizards SDK classes
	    in your <code>CLASSPATH</code> setting.  An example 
             directory structure that might be used is:
      <pre>
      classes
        --> com
            ---> sun
                 ---> wizards 
                        ---> awt
                        ---> core
                        ---> panels
                        ---> nodes
                        ---> builder
                        ---> rmi
                 ---> install
                        ---> products
                        ---> panels
                        ---> tasks
                        ---> nodes
            ---> companyName
                       ------> install
                                 ---> builders
                                 ---> panels
                                 ---> tasks
                                 ---> {other types}
</pre>
      You would then include the 'classes' directory in your <code>CLASSPATH</code> and
      import your customized classes with <code><strong>import com.companyName.install.panels.*;</strong></code>
      within your java code.
      <p>
      As an example, suppose you write a builder and place it in the <code>com.companyName.install.builders</code>
      package and name it <code>MyBuilder.java</code>.  To compile it, you would put the 'classes'
      directory in your <code>CLASSPATH</code> and type:
      <pre>
	<strong>javac com.companyName.install.builders.MyBuilder.java</strong>
      </pre>
      Then, assuming it wrote your wizard to the current directory and
      called it <code>install.class</code>, you would type <strong><code>java
	install</code></strong> to run your wizard.
      <p>
	    <li><h5><a name="CodeBuilder">Writing the Builder</a></h5>
      The builder is the part that ties all of the various pieces of the installation together and
      writes out the resulting <code>.class</code> file for distribution. All builders (whether custom or not)
      use the same basic skeleton builder to begin with:
      <pre>
      public class SkeletonBuilder extends InstallArchiveWriter
      {

        public SkeletonBuilder()
         {
           super();
         }

        protected void createClientTree()
         {
           super.createClientTree();

            /*
             * Customize your builder here
             */
         }

        public static void main(String[] args)
         {
           SkeletonBuilder myBuilder = new SkeletonBuilder();
           myBuilder.writeArchive();
         }
      }
      </pre>
      You can then add extra code in the <code>createClientTree()</code> method to customize your
      wizard.  
      <p>
	In your builder's <code>createClientTree()</code> method, you can include calls to customize some or all
	of your wizard, using <code>InstallArchiveWriter</code>'s API provided.  See the
	<a href="../../../docs/api/com.sun.install.products.InstallArchiveWriter.html"><code>InstallArchiveWriter</code></a> API for
	details of the methods available.  Some of the things you can customize are:
	<p>
	<ul>
	<li>What happens at wizard initialization time.
	<li>The name of the product.
	<li>The "About..." Message.  When the user clicks on the "About" button on the Welcome Panel, this message
	  is shown.  
	<li>The "Exit" Message.  When the user clicks on the "Exit" button before the wizard is finished installing,
	  this message is displayed.  You might want to warn the user about exiting too early.
	<li>The "Cancel" Message.  If the user cancels one of your sequences, this message is displayed.  An example of
	  when the "Cancel" button appear would be during installation.  All currently running sequences are paused while
	  the user verifies the button press.
	<li>The default installation directory.
	<li>The name of the resulting archive class filename.
	<li>The image displayed during the lifetime of the wizard.
	<li>The image displayed when the wizard is iconified.
      </ul>
      <p>
	<li><h5><a name="CodePanels">Creating Pre- and
	  Post-Installation User Interface Panels</a></h5> 
      If your
      product needs any pre-installation or post-installation
      configuration, you can write panels that will be
      displayed at the appropriate times during your
      installation, and interact with the server to make the
      configurations. Once written, you can place these panel sequences
      into the client panel tree in your builder using the
      <code>addNode()</code> method of
      <code>InstallArchiveWriter</code>.  A sample post-installation
      configuration panel is used in the SolarisBuilder
      below to configure the product after installation.
      <p>
	You should place your
      panel classes within your section of the development environment,
      separate from any Wizards SDK classes, and include the panels
      into your builder. 
	<p>For example, suppose I have created a
      post-configuration panel called "PostConfigurePanel.java" that prompts
      for the <code>sbin</code> directory of the system. I have
      placed the panel in the com.sun.myCompany.panels package.  In my builder, I might
      include this panel as a post-configuration panel by doing the following:
      <pre>
      import com.sun.myCompany.panels.*;
      [...]
      PreconfigurePanel myPanel = new PreconfigurePanel("/usr/sbin");
      addNode(PRE_VERIFY, myPanel);
      </pre>
      This panel will then be shown to the user before the 
      <a href="../../../docs/api/com.sun.install.panels.VerifyPanel.html">VerifyPanel</a>.  
      It is the panel's
      responsiblility to correctly configure the system based on user input.
      <p>
      <li><h5><a name="CodeTogether">Putting it all together</a></h5>
      In summary, for simple installations, only the builder needs to
      be written.  It can be as simple or as complex as you want. For
      more complex installations, the features of <code>InstallArchiveWriter</code>
      can be used to create a fully-cusomized wizard that does
      installation and configuration for your product.  For a complete
      example, go through the next section which presents a real-world
      example and walks you through the entire process of creating a
      customized wizard for a fictional product.
      </ul>
      <h3><a name="SolarisBuilder">4. Solaris Step-By-Step Example: SolarisBuilder.java</h3>
      <blockquote>
	  The following example builds a fictional product that
	  consists of two patches, and two packages.  The patches 
	  are required before the product
	  will be installed, and the Java Source Demos will only be
	    installed if the user has the Sun JDK version 1.1 on the
	    system.
	    <p>
	    </blockquote>
      <ul>
      <li><h5><a name="Sample Files">Sample Files Involved</a></h5>
      This demo features the following files:
      <p>
      <ul>
	<li><a href="../../../docs/api/com.sun.install.products.SunJDKDependency.html">A JDK Dependency</a>.
	<li>The samples <strong>more</strong>, <strong>stuf</strong>, and <strong>demo</strong> packages located in the 
          <a href="../packages"><code>[SDK Base Directory]/solaris/samples/packages</code></a> directory of the Webstart Wizards SDK.
	<li>The sample Patches 102342-04 and 102341-03, not provided.
      </ul>
      <p>
      These files are the ones you would have to provide if you were to build and distribute this product.
	<p><hr>
	<li><h3><a name="Step 1">Step 1:Laying out the product tree</a></h3> 
      <p> 
        The product tree is the internal wizard representation of your product.  It has nothing to do
        with the way the product files are organized on disk.  The product tree is built at <em>buildtime</em>
	and then used to install at <em>installtime</em> (also known as  <em>runtime</em>).
	<p>
        We first decide how we want to ship our product.
	We know we have to apply a patch first, and then install our
	product.  We also have some demos we would like the customer
	to optionally be able to install, but only if they have a Sun JDK 1.1-
        compliant system.
      <p>
	The packages <strong>more</strong>, <strong>stuf</strong>, and <strong>demo</strong> 
        have been built already and we cannot
	change them.  <strong>more</strong> and <strong>stuf</strong> install on all Solaris platforms, so we
	do not need to worry about any platform dependencies.
	However, our two Solaris Patches must be installed differently
	depending on if we are on Solaris SPARC or Solaris Intel.
	Therefore, we place each patch underneath a platform
	dependency.  This way, only one patch will be applied at
	install time.  If we are on an Intel-based Solaris system,
	then patch 102342-04 will be applied.  Otherwise, if we are on
	a SPARC-based Solaris system, then patch 102341-03 will be
	applied.
	<p>
	Therefore, our product tree conceptually looks like this:
      <center><h2>Product Tree </h2></center>
      <strong><pre>

                              [PRODUCT]
                                  |
     +----------------------------+-------------------------------+
     |                            |                               |
[Required Patches]**       [Sun Web Product]*                  [Demos]
     |                            |                               |
     |                            |                               |
 +---+-------------+         +----+------------+       [JDK 1.1 Dependency]
 |                 |         |                 |                  |
 |                 |      [more]            [stuf]                |
[SPARC Dep.]       |                                            [demo]
 |            [X86 Dependency]     
 |                 |     
 |                 |     
[102341-03]   [102342-04] 


NOTE:
** Required Component
*  Optional Component
</pre></strong>
<hr>
	<li><h3><a name="Step 2">Step 2:Begin the Builder</a></h3> 
      We will create a skeleton builder, then add pieces into it until
      we have finished.  Begin your builder by writing this simple
      builder that doesn't do anything into a file called
      <code>SolarisBuilder.java</code> in the Web Start Wizards SDK
      <strong>"classes"</strong> directory:

      <strong><pre>
import com.sun.install.panels.*;
import com.sun.install.products.*;
import com.sun.wizards.core.*;
import com.sun.wizards.builder.resolver.*;
import java.util.*;
import java.io.*;

public class SolarisBuilder extends InstallArchiveWriter
{
  public SolarisBuilder()
  {
    super();
  } 
  
  protected void createClientTree()
  {
    /*
     * Customization code goes ABOVE here
     */
     super.createClientTree();
  }

  public static void main(String[] args)
  {
     SolarisBuilder sampleBuilder = new SolarisBuilder();
     sampleBuilder.writeArchive();
  }

}
      </pre></strong>
      <p>
	This class extends <code>InstallArchiveWriter</code> so that we can use some of its
	convenience methods created for making <em>install</em> wizards.  We also override
	<code>createClientTree()</code> because this is where we are going to make our wizard
	do something instead of not doing anything.
	<p>
	You can compile and run this class if you wish.  To compile it, type:
	<strong><pre>
% javac SolarisBuilder.java
        </pre></strong>
        Do not type the '%'.  That is an indication of a command prompt.  
        To run the resulting class, type:
        <strong><pre>
% java SolarisBuilder
</pre></strong>
      It will complain:
      <strong><pre>
Nothing to do: No components added, quitting...
</pre></strong>
      This is because we have not added any components, and could not create an installation wizard.
      <hr><li><h3><a name="Step 3">Step 3: Set the Product Name and Default Directory</a></h3> 
      Add this code to the <code>createClientTree</code> method:
      <strong><pre>
setProductName("Solaris Example Product");
setDefaultDirectory("[userDir]/myProduct");
      </pre></strong>
      The <code>[userDir]</code> key in the second line gets replaced at runtime with the "home" directory for the user
      that is running the wizard.  There are other substitutions one could do:
      <p>
      <ul>
	  <li><code>[productDir]</code> = Standard install directory (<code>/opt</code> on Solaris)
	  <li><code>[sharedLibDir]</code> = Shared Library directory (<code>/usr/lib</code> on Solaris)
	  <li><code>[tmpDir]</code> = Temporary scratch directory (<code>/tmp</code> on Solaris)
          <li><code>[currentDir]</code> = Current directory
	  </li>
      </ul>
      <hr><li><h3><a name="Step 4">Step 4: Set the Name of the Images to Display</a></h3> 
      Add this code to the <code>createClientTree()</code> method:
      <strong><pre>
setImage("com.sun.install.install");
      </pre></strong>
      The <code>com.sun.install.install</code> specification means that the image exists in the <code>com/sun/install</code>
      directory relative to your <code>CLASSPATH</code> (or current directory if no class path is set), and is called
      install.gif, install.jpg, install.jpeg, or install.jfif.  You must also make sure that your image gets put into the archive
      by configuring a FileResolver to get the image, and adding the image to a ResourceCollection so that it gets resolved and put into the archive. 

      To do this, add this code to the <code>createClientTree()</code> method:

      <strong><pre>
FileResolver resolver = new FileResolver(System.getProperty("java.class.path"));
ResourceCollection collection = new ResourceCollection();
collection.addResource("Images", "com.sun.install.install", resolver);
addCollection(collection);
     </pre></strong>
      <hr><li><h3><a name="Step 5">Step 5: Set Any Configurable Messages</a></h3> 
      Add this code somewhere above the <code>super.createClientTree()</code>line:
<strong><pre>
setAboutMsg(new Msg("com.sun.install.Install", "AboutText"));
setCancelMsg(new Msg("com.sun.install.Install", "CancelAreYouSure"));
setExitMsg(new Msg("com.sun.install.Install", "ExitAreYouSure"));
</pre></strong> 
      This sets some configurable messages. If you do not specify an
      "About..." message, then the about button will not be displayed
      on the Welcome Panel.  The others will default to default
      values.  The About message is displayed when the user clicks the
      "About" button on the Welcome Panel.  The Cancel message is
      displayed when the user cancels some operation such as install
      or disk space checking, by clicking the "Cancel" button.  The
      Exit Message displays when the user clicks the "Exit" button.
      <p>
	Note that these messages are localized. At runtime, the
	specified locale resource bundle is searched according to the
	runtime locale.  In this case the resource bundle "com.sun.install.Install" will
	be searched for a message corresponding to the supplied keys. 
      <hr><li><h3><a name="Step 6">Step 6:Build the Product Components</a></h3> 
      Add this code somewhere above the <code>super.createClientTree()</code>line:
      <strong><pre>
SoftwareComponent requiredPatches = new SoftwareComponent(new Msg("Required Patches"));
SoftwareComponent webProduct = new SoftwareComponent(new Msg("Sun Web Product"));
SoftwareComponent demos = new SoftwareComponent(new Msg("Java Source Demos"));
      </pre></strong>
A SoftwareComponent represents a logical software
<em>component</em> and can be selected and de-selected by the user.
<p>
Each one is given a name that will appear to the user on the Component
Selection screen.    

<hr><li><h3><a name="Step 7">Step 7:Create Platform Objects</a></h3>
      Add this code to the <code>createClientTree()</code> method:
<pre><strong>
      Platform sparcPlatform = new Platform(Platform.ALL, Platform.SOLARIS, Platform.SPARC);
      Platform x86Platform = new Platform(Platform.ALL, Platform.SOLARIS,Platform.X86);
</pre></strong>
These objects represent specific platforms (such as Sparc Solaris, or WindowsNT).  These objects
can be used to build <i>Platform Dependencies</i>.  See the API Documentation for instructions on how
to specify your own platform.
<hr><li><h3><a name="Step 8">Step 8:Create Platform Dependencies</a></h3>
      Add this code below the previous section but somewhere above the <code>super.createClientTree()</code>line:
      <pre><strong>
PlatformDependency sparcDependency = new PlatformDependency(sparcPlatform, false);
PlatformDependency x86Dependency = new PlatformDependency(x86Platform, false);
SunJDKDependency JDK11Dependency = new SunJDKDependency(">=1.1", false);
      </pre></strong>
These Platform Dependencies are objects inserted into the product tree.
They compare the supplied Platform object to the current platform and
"fail" if they do not match.  
<p>
You can also <em>invert</em> the dependencies, which cause them to "pass"
when their dependencies "fail", by passing <code>true</code> as the second
argument to the constructor.
<p>
Note the specification of <code>">=1.1"</code>.  This means Java version 1.1 or later.
<p>
These will be checked just before the
installation takes place, and if the platforms do not match up, they
will not install anything that is attached in the tree below that
object.
<p>
You can create your own custom Dependency by creating a class that
extends <strong><code>com.sun.install.products.InstallNode</code></strong> and
implement the <code>refresh()</code> method.  The <code>refresh()</code>
method should set the <code>nodeIsActive</code> property to <code>Boolean(true)</code> if
the dependency is <code>true</code>.  Then you can insert your new Dependency into the
tree just as we have done here.
<p>
The SunJDKDependency is an example of how this might be done.  You create one by passing the
version of the Sun JDK you are looking for.  It has the following <code>refresh()</code>
method:
<pre>
public boolean refresh(Vector targets, String sharedPoolKey)
  {
    RunCmd versionCheck = new RunCmd("/usr/bin/java -version", true);
    String result = versionCheck.getAllOutput();
    if ((result != null) && (isCompatible(result))
      {
        nodeIsActive = !invert;
      }
    else
      {
        nodeIsActive = false;
      }
  }
</pre>
<p>
The <code>isCompatible()</code> method simply checks to see if the two version strings are compatible,
and is irrelevent to this topic.
<p>
Note that if the <code>invert</code> flag (a flag within the class) is <code>true</code> we
must <em>invert</em> the output; that is, set nodeIsActive to the opposite of what we would
normally set it to.
<hr><li><h3><a name="Step 9">Step 9: Create Solaris Patch Components</a></h3>
      Add this code below the previous section but somewhere above the <code>super.createClientTree()</code>line:
<pre><strong>
PatchUnit sparcUsrPatch = new PatchUnit("../sparc", "102341-03");
PatchUnit x86UsrPatch = new PatchUnit("../sparc", "102342-04");
</pre></strong>
Creates our SPARC Solaris patch. We pass it the relative path to this 
patch (which must exist at that relative path at runtime), and the revision number.
<p>
<hr><li><h3><a name="Step 10">Step 10: Create Solaris Package Components</a></h3>
      Add this code below the previous section but somewhere above the <code>super.createClientTree()</code>line:
<pre><strong>
Hashtable variables = new Hashtable();
variables.put("basedir", InstallConstants.currentInstallDirectory);
PkgUnit webPkg1 = new PkgUnit("../samples/solaris/packages", "more", 
                                "../samples/solaris/packages/admin", 
                                "../samples/solaris/packages/response", 
                                variables, PkgUnit.BUILD_TIME);
PkgUnit webPkg2 = new PkgUnit("../samples/solaris/packages", "stuf", 
                                "../samples/solaris/packages/admin", 
                                "../samples/solaris/packages/response", 
                                variables, PkgUnit.BUILD_TIME);
PkgUnit sunDemoPkg = new PkgUnit("../samples/solaris/packages", "demo",
	                         "../samples/solaris/packages/admin", 
                                 "../samples/solaris/packages/response", 
                                 variables, PkgUnit.BUILD_TIME);
	  
</pre></strong>
Creates our SVR4 package units.  
<p>
These lines actually creates the PkgUnits.  The arguments are as follows:
<p>
<ul>

<li><code>"../samples/solaris/packages"</code> - The relative directory to the package.
At runtime, the package is located using this relative directory and
the package name.  In this example, the package would be located at
<code>../samples/solaris/packages/stuf</code>.
<p>
<li><code>"stuf"</code> - The actual name of the SVR4 package.
<p>
<li><code>"../samples/solaris/packages/admin"</code> - The relative path to the "admin" files
for this product.  Each SVR4 package can have an admin file in this
directory, with each admin file named the same as the name of the
package (<code>stuf</code>, in this case).  The admin file is read during
initialization.  It is then available to your wizard in the wizard
archive as a hashtable (<code>name=value</code> pairs).  If you want
to change the admin file according to user input, you could create a
panel that takes user input, retrieves the admin file from the wizard
state, modifies a value, and writes it back.  The wizard state key is
"admin.{package name}", in this case <code>admin.stuf</code>.
<p>
During installation, the admin file is written to a temporary
directory and passed to <em>pkgadd</em>.  If no admin file is
specified here, or if the admin file cannot be found at runtime, a
<a href="#admin">default admin file</a> is generated (see the <a href="../../../docs/api/com.sun.install.products.PkgUnit.html">PkgUnit API documentation</a> for more information on how this is done).
<p>
<li><code>"../samples/solaris/packages/response"</code> - The relative path to the "response"
directory containing the response files for this product.  
Each SVR4 package can have a response file in
this directory, with each response file named the same as the name of
the package (<code>stuf</code>, in this case).  The response file is read
during initialization.  It is then available to your wizard in the
wizard archive as a hashtable (<code>name=value</code> pairs). If you
want to change the response file according to user input, you could
create a panel that takes user input, retrieves the response file from
the wizard state, modifies a value, and writes it back.  The wizard
state key is "response.{package name}", in this case
<code>response.stuf</code>.
<p>
<li><code>variables</code> - The installation variables to pass to <code>pkgadd</code>.
  This feature is new with the 3.0 <code>PkgUnit</code> class.  See the <a href="../../../docs/api/com.sun.install.products.PkgUnit.html">
  PkgUnit API Documentation</a> for more details on this feature.  Basically, SVR4 Packages can have <em>dynamic
  variables</code> used in their <code>pkgmap</code> file.  For instance, a package might have a line in it's <code>pkgmap</code>
 such as:
<pre>
1 f none $USERDIR/Demo1.java 0600 jhf staff 512000 0 909092253
</pre>
<p>This means that the file <code>Demo1.java</code> will be placed into the directory that is specified by the
<code>USERDIR</code> installation variable, which must exist in the environment during the <code>pkgadd</code> 
invocation. 
<p>
The <em>variables</em> hashtable passed to the PkgUnit constructor enumerates which variables must be set when 
the wizard calls <code>pkgadd</code> for this package.  For each <code>key=value</code> pair in the hashtable, the
<code>key</code> represents the variable name, and the <code>value</code> represents the Wizard State variable under which
the value for the variable is.  The value is looked up, and the setting is placed into the response file if the value exists.
<p>
The special case is the <code>basedir</code> setting, which actually goes into the <em>admin</em> file.  This setting 
applies to <em>all</em> relocatable SVR4 packages.
If you want your package to relocate into the directory that the user types into the
<a href="../../../docs/api/com.sun.install.panels.DirectorySelectionPanel"></a>DirectorySelectionPanel</code></a>
then you must pass in a hashtable which has the entry:
<pre>
variables.put("basedir", InstallConstants.currentInstallDirectory);
</pre>
Which says "look up the string in the wizard state under the key <code>InstallConstants.currentInstallDirectory</code>, and place it
into the <code>pkgadd</code> environment as the setting for <code>basedir</code>.  This is what we have done in this example.
<p>
<li><code>PkgUnit.BUILD_TIME</code> - Tells PkgUnit to collect and calculate package size information when building the wizard, rather than doing it at <code>PkgUnit.RUN_TIME</code>.  Doing it at runtime allows you to build the wizard without having the actual package contents available.  However, this incurs a small runtime performance penalty when the size information is calculated at runtime.  If you have large packages, or many of them, it is advantageous (performance-wise) to do this at buildtime.<p>
</ul>

<hr><li><h3><a name="Step 11">Step 11: Build the product tree</a></h3>
      Add this code to the <code>createClientTree()</code> method:
<pre><strong>
sparcDependency.addComponent(sparcUsrPatch);
x86Dependency.addComponent(x86UsrPatch);
requiredPatches.addComponent(sparcDependency);
requiredPatches.addComponent(x86Dependency);
webProduct.addComponent(webPkg1);
webProduct.addComponent(webPkg2);
JDK11Dependency.addComponent(sunDemoPkg);
demos.addComponent(JDK11Dependency);

addComponent(requiredPatches, true, true);
addComponent(webProduct);
addComponent(demos);
</pre></strong>
These lines build the tree from the bottom-up. First we create the "Required Patches"
subtree, then the "Sun WebProduct" tree, and finally the "Demos" subtree. As we add
each component to another component, the tree is formed.   
<p>
The last 3 lines actually
add the fully-formed subtrees to the product itself.  The first one (requiredPatches)
is specified to be <em>required</em> by passing <code>true</code>; that is, the user will not be able to de-select
this component.  The others are optional. 
<hr><li><h3><a name="Step 12">Step 12: Create Configuration Panels</a></h3>
      Add this code to the <code>createClientTree()</code> method:
<pre><strong>
Object[] nameArgs = new Object[] {getProductName()};
DirectorySelectionPanel postConfigurePanel = new DirectorySelectionPanel(getWizardState(),
                    "Post Configuration Panel", "myDefaultDir", 
                    "myDefaultDir", "/usr/lib");
postConfigurePanel.addDescriptionText(new Msg("com.sun.install.Install", 
                                      "PostConfigDirectoryDescription", 
                                      nameArgs));
postConfigurePanel.addLabelText(new Msg("com.sun.install.Install", 
                                      "PostConfigTextLabel"));
addNode(POSTINSTALL, postConfigurePanel);
</pre></strong>
This creates a single Directory Selection panel and places it as a
<em>post-install panel</em>.  Post-install panels are shown after
installation.  You can also place <em>pre-install panels</em> which
are shown directly before installation.  The arguments to the DirectorySelectionPanel
constructor are:
<p>
<ul>
<li><code>wizardState</code> - The <em>buildtime</em> wizard state, available from the superclass.
<li><code>"Post Configuration Panel"</code> - Default heading for this panel
<li><code>"myDefaultDir"</code> - The wizard state key under which is stored the default 
   directory displayed in the panel.
<li><code>"myDefaultDir"</code> (again) - The wizard state key under which this panel 
   should store the entry made by the user.  This is stored via the <code>isDisplayComplete()</code> 
   method of the panel.
<li><code>"/usr/lib"</code> The default directory used during a panel reset, 
   normally this value is the same one stored under the default directory key.
</ul>
     
<p>
Note that the messages added using <code>addDescriptionText(..)</code> and <code>addLabelText(...)</code>
are localized. At runtime, the specified
locale resource bundle is searched according to the runtime locale. In
this case the resource bundle "com.sun.install.Install" will be
searched for a message corresponding to the supplied keys.
<p>
The DescriptionText is the text displayed to the user that describes
the data the panel is looking for.
<p>
The LabelText is the text displayed just above the text entry box
describing the contents of the entry box.
<p>
The addNode() argument is the type of panel this is
(either <code>PREINSTALL</code>, <code>POSTINSTALL</code>, 
 <code>POST_WELCOME</code>, or <code>PRE_VERIFY</code>) and the root of the panel tree
itself, or a single panel if desired.
<p>
You could create an entire subtree of panels and insert them as
post-install panels.  If you did this, the entire tree would be
visited after installation.  In those panels, you could do
post-install configuration of the newly-installed product according to
user input.  Or, you could do an electronic registration screen.
<hr><li><h3><a name="Step 13">Step 13: Finish the builder</a></h3>
add this method to the builder class, if it isn't there already:
<pre><strong>
public static void main(String[] args)
 {
   SolarisBuilder sampleBuilder = new SolarisBuilder();
   sampleBuilder.writeArchive();
   System.exit(0);
 }
</pre></strong>
This is the main method of your builder. This simply instantiates a builder
and writes it out to the current directory.
<p>
After this step, you should have a complete builder.
<hr><li><h3><a name="Step 14">Step 14: Compile & Run the builder & wizard</a></h3>
Once you have finished writing your builder you can go ahead and
compile and debug it. You can compile this builder by unsetting your <code>CLASSPATH</code>
and doing the following (on Solaris):
<pre>
$ unsetenv CLASSPATH
$ cd <strong>[Web Start SDK Base Directory]/classes</strong>
$ javac SolarisBuilder.java
</pre>
If there were no errors, you can now run your builder to create your wizard archive:

$ java SolarisBuilder

If there are no errors, your builder should have produced a <code>wizard.class</code> file in the current directory.
This is your wizard!  You can then run your wizard by typing:
<pre>
$ java wizard
</pre>
You should see your wizard come up with the Welcome Panel.  If it does
not, look for error messages that might explain why.
<p>
Since this example uses <code>pkgadd</code> and <code>patchadd</code>, you must run it with <em>root</em> priviledges.  All
wizards created that use <code>pkgadd</code> and/or <code>patchadd</code> will have this requirement.  To make this as easy
as possible, many people have created wrapper scripts that ask for the root password before executing the wizard.
</ul>
</blockquote>
This concludes this Solaris Tutorial.  For more information on creating wizards for Solaris, please visit our website
at <a href="http://www.sun.com/solaris/webstart/wizards/">www.sun.com/solaris/webstart/wizards/</a>.
<p>
